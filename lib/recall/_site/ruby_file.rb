### Output from Recall search


###########################

# File: /Users/samschlinkert/Documents/code/flatiron/scratch/blog/config/environments/production.rb
# Starting at line number: 18... 

    # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.
  config.assets.digest = true



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/scratch/blog/config/environments/production.rb
# Starting at line number: 17... 

  
  # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/lectures/sinatra-blog-ruby-004/spec/spec_helper.rb
# Starting at line number: 2... 

  require_relative '../config/environment'
require 'rack/test'

system("rm db/test.sqlite3")

ActiveRecord::Base.establish_connection(
  :adapter => "sqlite3",
  :database => 'db/test.sqlite3'
)

require_relative '../db/migrate/01_create_posts'
CreatePosts.migrate(:up)

# This file was generated by the `rspec --init` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# Require this file using `require "spec_helper"` to ensure that it is only
# loaded once.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/lectures/sinatra-blog-ruby-004/spec/spec_helper.rb
# Starting at line number: 21... 

  # Require this file using `require "spec_helper"` to ensure that it is only
# loaded once.
#
# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
RSpec.configure do |config|
  config.include Rack::Test::Methods

  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus

  # Run specs in random order to surface order dependencies. If you find an
  # order dependency and want to debug it, you can fix the order by providing
  # the seed, which is printed after each run.
  #     --seed 1234
  config.order = 'random'
end

def app
  subject
end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/lectures/sinatra-blog-ruby-004/spec/feature_helper.rb
# Starting at line number: 6... 

  require 'spec_helper'
require 'capybara'
require 'capybara/dsl'
require 'capybara/rspec'

Capybara.app = Rack::Builder.parse_file(File.expand_path("../../config.ru", __FILE__)).first

RSpec.configure do |config|
  config.include Capybara::DSL

end




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/lectures/rails-blog-ruby-004/config/environments/production.rb
# Starting at line number: 18... 

    # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.
  config.assets.digest = true



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/lectures/rails-blog-ruby-004/config/environments/production.rb
# Starting at line number: 17... 

  
  # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/the-big-todo-ruby-004/config/environments/production.rb
# Starting at line number: 18... 

    # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.
  config.assets.digest = true



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/the-big-todo-ruby-004/config/environments/production.rb
# Starting at line number: 17... 

  
  # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/rails-blog-scaffold-ruby-004/config/environments/production.rb
# Starting at line number: 18... 

    # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.
  config.assets.digest = true



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/rails-blog-scaffold-ruby-004/config/environments/production.rb
# Starting at line number: 17... 

  
  # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/pollywog-ranch-rails-ruby-004/config/environments/production.rb
# Starting at line number: 18... 

    # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.
  config.assets.digest = true



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/pollywog-ranch-rails-ruby-004/config/environments/production.rb
# Starting at line number: 17... 

  
  # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/playlister-sinatra-ruby-004/spec/spec_helper.rb
# Starting at line number: 4... 

  ENV["SINATRA_ENV"] = "test"

require_relative '../config/environment'
require 'rack/test'
require 'capybara/rspec'
require 'capybara/dsl'

if ActiveRecord::Migrator.needs_migration?
  raise 'Migrations are pending. Run `rake db:migrate SINATRA_ENV=test` to resolve the issue.'
end

RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus
  config.include Rack::Test::Methods
  config.include Capybara::DSL
  DatabaseCleaner.strategy = :truncation




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/playlister-sinatra-ruby-004/spec/spec_helper.rb
# Starting at line number: 32... 

  
  config.order = 'default'
end

def app
  Rack::Builder.parse_file('config.ru').first
end

Capybara.app = app


###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/playlister-sinatra-ruby-004/spec/spec_helper.rb
# Starting at line number: 16... 

  
RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus
  config.include Rack::Test::Methods
  config.include Capybara::DSL
  DatabaseCleaner.strategy = :truncation

  config.before do
    DatabaseCleaner.clean
  end

  config.after do
    DatabaseCleaner.clean
  end

  config.order = 'default'
end

def app



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/join-the-fun-rails-ruby-004/config/environments/production.rb
# Starting at line number: 18... 

    # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.
  config.assets.digest = true



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/join-the-fun-rails-ruby-004/config/environments/production.rb
# Starting at line number: 17... 

  
  # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/fuck_you_rails/weblog/config/environments/production.rb
# Starting at line number: 18... 

    # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.
  config.assets.digest = true



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/fuck_you_rails/weblog/config/environments/production.rb
# Starting at line number: 17... 

  
  # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/formal-affair-rails-ruby-004/config/environments/production.rb
# Starting at line number: 18... 

    # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.
  config.assets.digest = true



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/formal-affair-rails-ruby-004/config/environments/production.rb
# Starting at line number: 17... 

  
  # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/flatiron-kitchen-ruby-004/config/environments/production.rb
# Starting at line number: 18... 

    # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.
  config.assets.digest = true



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week6/flatiron-kitchen-ruby-004/config/environments/production.rb
# Starting at line number: 17... 

  
  # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-students-ruby-004/spec/spec_helper.rb
# Starting at line number: 4... 

  ENV["SINATRA_ENV"] = "test"

require_relative '../config/environment'
require 'rack/test'
require 'capybara/rspec'
require 'capybara/dsl'

if ActiveRecord::Migrator.needs_migration?
  raise 'Migrations are pending. Run `rake db:migrate SINATRA_ENV=test` to resolve the issue.'
end

RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus
  config.include Rack::Test::Methods
  config.include Capybara::DSL

  config.before(:suite) do



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-students-ruby-004/spec/spec_helper.rb
# Starting at line number: 34... 

  
  config.order = 'default'
end

def app
  Rack::Builder.parse_file('config.ru').first
end

Capybara.app = app


###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-students-ruby-004/spec/spec_helper.rb
# Starting at line number: 16... 

  
RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus
  config.include Rack::Test::Methods
  config.include Capybara::DSL

  config.before(:suite) do
    DatabaseCleaner.strategy = :transaction
    DatabaseCleaner.clean_with(:truncation)
  end

  config.around(:each) do |example|
    DatabaseCleaner.cleaning do
      example.run
    end
  end

  config.order = 'default'
end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-students-ruby-004/spec/controllers/students_controller_spec.rb
# Starting at line number: 25... 

      #    It's nice if you can isolate your controller tests from the database.
    #    However, feel free to never use something like should_receive and 
    #    just use as many real objects as you want.

    # 2. It creates a mock web request to the route '/' so that our tests
    #    can check the response to that request through the Rack::Test provided
    #    method 'last_response', which will always mean the last response
    #    our test suite triggered.
    before do
      Student.should_receive(:all).and_return([student])
      get '/'
    end

    # A good controller test you can write for every single route/action
    # is to make sure it responds with a 200 status code.
    it 'responds with a 200' do
      # We use the last_response object to test the properties of the response
      # sinatra would send to the request. last_response behaves a lot like an
      # HTTP, with methods to provide a status code and the body of the response
      # A shortcut to checking the status is to just say it is ok with the line below.
      expect(last_response).to be_ok



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-students-ruby-004/config/environment.rb
# Starting at line number: 22... 

  # ENV is a constant that is provided by ruby that stores Environmental
# variables in a hash. These variables cross the boundary of our application,
# to the system the application runs on. Thus, a command line argument
# or a BASH variable will be present in this object.

# Rack likes to store the mode our application should run within a variable
# called SINATRA_ENV with ENV. This allows our application to run in different
# modes with different settings and configurations.

# The two modes we are interested in are "development" and "test".

# Establish our Database connection.
ActiveRecord::Base.establish_connection(
  :adapter => "sqlite3",
  :database => "db/#{ENV['SINATRA_ENV']}.sqlite"
)

# require_all is a gem that you pass it a directory
# and it loads all .rb in there.
# https://github.com/jarmo/require_all




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-students-ruby-004/app/controllers/application_controller.rb
# Starting at line number: 1... 

  # This is the main application controller. It is mounted as the Rack application
# in config.ru. The purpose of this class is to provide an inheritance point for
# the rest of our controllers.

# Do not code routes or controller actions within this class.

class ApplicationController < Sinatra::Base
  # A custom view path to support a more MVC structure.
  # This will point all views to app/views, leaving you to specify
  # the controller subfolder and the view when rendering erb.
  # See the example in students_controller.rb, get '/'.
  set :views, File.expand_path('../../views', __FILE__)
  
  register Sinatra::ActiveRecordExtension
  set :session_secret, "my_application_secret"
end


###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-orm-halloween-ruby-004/spec/spec_helper.rb
# Starting at line number: 4... 

  ENV["SINATRA_ENV"] = "test"

require_relative '../config/environment'
require 'rack/test'

if defined?(ActiveRecord::Migrator) && ActiveRecord::Migrator.needs_migration?
  raise 'Migrations are pending run `rake db:migrate SINATRA_ENV=test` to resolve the issue.'
end

RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus
  config.include Rack::Test::Methods
  
  config.before(:suite) do
    DatabaseCleaner.strategy = :transaction
    DatabaseCleaner.clean_with(:truncation)
  end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-orm-halloween-ruby-004/spec/spec_helper.rb
# Starting at line number: 31... 

  
  config.order = 'default'
end

def app
  Rack::Builder.parse_file('config.ru').first
end


###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-orm-halloween-ruby-004/spec/spec_helper.rb
# Starting at line number: 14... 

  
RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus
  config.include Rack::Test::Methods
  
  config.before(:suite) do
    DatabaseCleaner.strategy = :transaction
    DatabaseCleaner.clean_with(:truncation)
  end

  config.around(:each) do |example|
    DatabaseCleaner.cleaning do
      example.run
    end
  end

  config.order = 'default'
end




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-nested-forms-ruby-004/spec/spec_helper.rb
# Starting at line number: 3... 

  
require_relative '../config/environment'
require 'rack/test'

system("rm db/test.sqlite3")

ActiveRecord::Base.establish_connection(
  :adapter => "sqlite3",
  :database => 'db/test.sqlite3'
)


require_relative '../db/migrate/01_create_pirates.rb'
require_relative '../db/migrate/02_create_ships.rb'
CreatePirates.migrate(:up)
CreateShips.migrate(:up)





###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-nested-forms-ruby-004/spec/spec_helper.rb
# Starting at line number: 28... 

  # loaded once.
#
# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
RSpec.configure do |config|

  config.include Rack::Test::Methods

  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus

  # Run specs in random order to surface order dependencies. If you find an
  # order dependency and want to debug it, you can fix the order by providing
  # the seed, which is printed after each run.
  #     --seed 1234
  config.order = 'default'
end


def app 
  subject



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-complex-forms-ruby-004/spec/spec_helper.rb
# Starting at line number: 4... 

  ENV["SINATRA_ENV"] = "test"

require_relative '../config/environment'
require 'rack/test'
require 'capybara/rspec'
require 'capybara/dsl'

if defined?(ActiveRecord::Migrator) && ActiveRecord::Migrator.needs_migration?
  raise 'Migrations are pending run `rake db:migrate SINATRA_ENV=test` to resolve the issue.'
end

RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus
  config.include Rack::Test::Methods
  config.include Capybara::DSL

  config.before(:suite) do



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-complex-forms-ruby-004/spec/spec_helper.rb
# Starting at line number: 34... 

  
  config.order = 'default'
end

def app
  Rack::Builder.parse_file('config.ru').first
end

Capybara.app = app


###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week5/sinatra-complex-forms-ruby-004/spec/spec_helper.rb
# Starting at line number: 16... 

  
RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus
  config.include Rack::Test::Methods
  config.include Capybara::DSL

  config.before(:suite) do
    DatabaseCleaner.strategy = :transaction
    DatabaseCleaner.clean_with(:truncation)
  end

  config.around(:each) do |example|
    DatabaseCleaner.cleaning do
      example.run
    end
  end

  config.order = 'default'
end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/sinatra-rspec-intro-ruby-004/spec/spec_helper.rb
# Starting at line number: 7... 

  # so that we can let sinatra and rack know that we are running in test mode

ENV['RACK_ENV'] = 'test'

require_relative '../app'
require 'rack/test'

# These are helpers for rspec that allow us to use things like last_response
# in our tests. We require it at top level in spec_helper so every spec
# that requires spec_helper gets access to them
include Rack::Test::Methods

RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.formatter = :documentation

  config.order = 'random'
end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/sinatra-rspec-intro-ruby-004/spec/spec_helper.rb
# Starting at line number: 2... 

  # here we are setting the environment variable RACK_ENV to 'test'
# so that we can let sinatra and rack know that we are running in test mode

ENV['RACK_ENV'] = 'test'

require_relative '../app'
require 'rack/test'

# These are helpers for rspec that allow us to use things like last_response
# in our tests. We require it at top level in spec_helper so every spec
# that requires spec_helper gets access to them
include Rack::Test::Methods

RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.formatter = :documentation



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/sinatra-rspec-intro-ruby-004/spec/spec_helper.rb
# Starting at line number: 12... 

  require 'rack/test'

# These are helpers for rspec that allow us to use things like last_response
# in our tests. We require it at top level in spec_helper so every spec
# that requires spec_helper gets access to them
include Rack::Test::Methods

RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.formatter = :documentation

  config.order = 'random'
end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/sinatra-rspec-intro-ruby-004/spec/route_spec.rb
# Starting at line number: 5... 

  require_relative 'spec_helper'

describe "routes" do

  # this is something that Rack::Test needs defined
  # in order to run tests against the Sinatra App
  # you'll see it inside each of our top-level describes

  def app
    TestApp
  end

  # notice that we are only checking for a valid route
  # and not any content specifically. These are "route"
  # tests that define what routes our application handles
  # the tests for our individual routes and the operations
  # they perform are in the other spec files

  # separation of concerns applies in tests, too!




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/sinatra-rspec-intro-ruby-004/spec/route_spec.rb
# Starting at line number: 39... 

  
    expect(last_response.status).to eq(200)
  end

  it "handles POST to /" do
    # 'post' is a helper from Rack::Test
    # it specifies a post request.

    post '/'
    expect(last_response).to be_ok
  end

  it "handles GET to /about" do
    get '/about'
    expect(last_response).to be_ok
  end

  it "handles GET to /hello" do
    get '/hello'
    expect(last_response).to be_ok
  end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/sinatra-rspec-intro-ruby-004/spec/route_spec.rb
# Starting at line number: 28... 

      # which is included in spec_helper.
    # it specifies a get request.

    get '/'

    # be_ok is a helper from Rack::Test

    expect(last_response).to be_ok

    # be_ok is the equivalent
    # of checking for HTTP status code 200

    expect(last_response.status).to eq(200)
  end

  it "handles POST to /" do
    # 'post' is a helper from Rack::Test
    # it specifies a post request.

    post '/'
    expect(last_response).to be_ok



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/sinatra-rspec-intro-ruby-004/spec/route_spec.rb
# Starting at line number: 22... 

    # they perform are in the other spec files

  # separation of concerns applies in tests, too!

  it "handles GET to /" do
    # 'get' is a helper from Rack::Test
    # which is included in spec_helper.
    # it specifies a get request.

    get '/'

    # be_ok is a helper from Rack::Test

    expect(last_response).to be_ok

    # be_ok is the equivalent
    # of checking for HTTP status code 200

    expect(last_response.status).to eq(200)
  end




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/004.a.twitterlink.rack.app/app.rb
# Starting at line number: 81... 

  # Now look and see what people are saying about the Flatiron School on Twitter!
#
# What else can you build into this? Check out the Twitter gem
# here https://github.com/sferik/twitter
#
# See what else you can do with rack!



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/004.a.twitterlink.rack.app/app.rb
# Starting at line number: 71... 

  # Okay and now our Rack Handler to actually load the application
# on port 3002 of our computer.

Rack::Handler::WEBrick.run(App.new, {:Port => 3002})

# You should see the Rack output letting you know you have a server
# running, this time on port 3002.

# Open your browser again to http://localhost:3002
#
# Now look and see what people are saying about the Flatiron School on Twitter!
#
# What else can you build into this? Check out the Twitter gem
# here https://github.com/sferik/twitter
#
# See what else you can do with rack!



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/004.a.twitterlink.rack.app/app.rb
# Starting at line number: 6... 

  # We need a few superpowers for this example. Obviously,
require 'rack'
require 'pry'

# Ignore this line.
Signal.trap('INT') {Rack::Handler::WEBrick.shutdown}

# Now let's grab the superpower twitter.

# https://github.com/sferik/twitter

# First, install the twitter gem from your terminal.

# gem install twitter

# Great, let's get it in this script.

require 'twitter'

TWITTER = Twitter::REST::Client.new do |config|
  # I got this information from creating a new twitter application



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/004.a.twitterlink.rack.app/app.rb
# Starting at line number: 69... 

  end

# Okay and now our Rack Handler to actually load the application
# on port 3002 of our computer.

Rack::Handler::WEBrick.run(App.new, {:Port => 3002})

# You should see the Rack output letting you know you have a server
# running, this time on port 3002.

# Open your browser again to http://localhost:3002
#
# Now look and see what people are saying about the Flatiron School on Twitter!
#
# What else can you build into this? Check out the Twitter gem
# here https://github.com/sferik/twitter
#
# See what else you can do with rack!



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/004.a.twitterlink.rack.app/app.rb
# Starting at line number: 66... 

  
    [200, {'Content-Type' => 'text/html'}, [html]]
  end
end

# Okay and now our Rack Handler to actually load the application
# on port 3002 of our computer.

Rack::Handler::WEBrick.run(App.new, {:Port => 3002})

# You should see the Rack output letting you know you have a server
# running, this time on port 3002.

# Open your browser again to http://localhost:3002
#
# Now look and see what people are saying about the Flatiron School on Twitter!
#
# What else can you build into this? Check out the Twitter gem
# here https://github.com/sferik/twitter
#
# See what else you can do with rack!



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/004.a.twitterlink.rack.app/app.rb
# Starting at line number: 34... 

  
# What do you think is going on up there? Well the twitter gem gives us a class,
# Twitter. We're configure the class with our credentials. Now that class basically
# represents twitter.

# Let's make our rack app.

class App

  def linkify(tweet)
    word_array = tweet.split(' ')
    regex = "(((ftp|https?):\/\/)(www.)?|www.)([\da-z-.]+)([a-z.]{2,7})([\/\w.-\?\&])\/?"
    
    # 1. find dead links
    # 2. gsub for hot links
    # 3. return new string that has a tags in it

  end

  def call(env)
    html = "<h1>What people are saying about Flatiron School</h1>"



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/004.a.twitterlink.rack.app/app.rb
# Starting at line number: 2... 

  # We need a few superpowers for this example. Obviously,
require 'rack'
require 'pry'

# Ignore this line.
Signal.trap('INT') {Rack::Handler::WEBrick.shutdown}

# Now let's grab the superpower twitter.

# https://github.com/sferik/twitter

# First, install the twitter gem from your terminal.

# gem install twitter

# Great, let's get it in this script.




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/003.a.magic.rack.app/app.rb
# Starting at line number: 6... 

  # We need a few superpowers for this example. Obviously,
require 'rack'
require 'pry'

# Ignore this line.
Signal.trap('INT') {Rack::Handler::WEBrick.shutdown}

# Now let's grab the superpower twitter.

# https://github.com/sferik/twitter

# First, install the twitter gem from your terminal.

# gem install twitter

# Great, let's get it in this script.

require 'twitter'

TWITTER = Twitter::REST::Client.new do |config|
  # I got this information from creating a new twitter application



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/003.a.magic.rack.app/app.rb
# Starting at line number: 69... 

  # Now look and see what people are saying about the Flatiron School on Twitter!
#
# What else can you build into this? Check out the Twitter gem
# here https://github.com/sferik/twitter
#
# See what else you can do with rack!



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/003.a.magic.rack.app/app.rb
# Starting at line number: 59... 

  # Okay and now our Rack Handler to actually load the application
# on port 3002 of our computer.

Rack::Handler::WEBrick.run(App.new, {:Port => 3002})

# You should see the Rack output letting you know you have a server
# running, this time on port 3002.

# Open your browser again to http://localhost:3002
#
# Now look and see what people are saying about the Flatiron School on Twitter!
#
# What else can you build into this? Check out the Twitter gem
# here https://github.com/sferik/twitter
#
# See what else you can do with rack!



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/003.a.magic.rack.app/app.rb
# Starting at line number: 57... 

  end

# Okay and now our Rack Handler to actually load the application
# on port 3002 of our computer.

Rack::Handler::WEBrick.run(App.new, {:Port => 3002})

# You should see the Rack output letting you know you have a server
# running, this time on port 3002.

# Open your browser again to http://localhost:3002
#
# Now look and see what people are saying about the Flatiron School on Twitter!
#
# What else can you build into this? Check out the Twitter gem
# here https://github.com/sferik/twitter
#
# See what else you can do with rack!



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/003.a.magic.rack.app/app.rb
# Starting at line number: 54... 

  
    [200, {'Content-Type' => 'text/html'}, [html]]
  end
end

# Okay and now our Rack Handler to actually load the application
# on port 3002 of our computer.

Rack::Handler::WEBrick.run(App.new, {:Port => 3002})

# You should see the Rack output letting you know you have a server
# running, this time on port 3002.

# Open your browser again to http://localhost:3002
#
# Now look and see what people are saying about the Flatiron School on Twitter!
#
# What else can you build into this? Check out the Twitter gem
# here https://github.com/sferik/twitter
#
# See what else you can do with rack!



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/003.a.magic.rack.app/app.rb
# Starting at line number: 34... 

  
# What do you think is going on up there? Well the twitter gem gives us a class,
# Twitter. We're configure the class with our credentials. Now that class basically
# represents twitter.

# Let's make our rack app.

class App
  def call(env)
    html = "<h1>What people are saying about Flatiron School</h1>"
    html << "<ul>"

    # So far we've created an HTML string. Now the fun part. 
    # Let's search twitter.
    twitter_search_results = TWITTER.search("flatironschool")
    twitter_search_results.each do |tweet|
      # So now we have these individual tweet objects, twitter statuses.
      html << "<li>#{tweet.user.name} says: #{tweet.text}</li>"
    end
    html << "</ul>"




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/003.a.magic.rack.app/app.rb
# Starting at line number: 2... 

  # We need a few superpowers for this example. Obviously,
require 'rack'
require 'pry'

# Ignore this line.
Signal.trap('INT') {Rack::Handler::WEBrick.shutdown}

# Now let's grab the superpower twitter.

# https://github.com/sferik/twitter

# First, install the twitter gem from your terminal.

# gem install twitter

# Great, let's get it in this script.




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/002.a.dynamic.rack.app/app.rb
# Starting at line number: 64... 

  
# Okay, exit out of that server, shut it down with CTRL+C

# So we can put anything in that response? Hmm. I wonder what we can do...

# Continue to 003.magic.rack.app


###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/002.a.dynamic.rack.app/app.rb
# Starting at line number: 4... 

  # Again, ignore the following line.
Signal.trap('INT') {Rack::Handler::WEBrick.shutdown}

# We left off with this amazing but boring Ruby Rack powered
# application.

class App
  def call(env)
    [200, {'Content-Type' => 'text/html'}, ["Hi from Ruby 004, we &#9829; you!"]]
  end
end

# But wait, if we're going to be building Rack applications,
# we have to integrate that superpower into this current script.

require 'rack'

# Okay, so now we know that application above will respond with a static string.
# But what about a more complex one?



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/002.a.dynamic.rack.app/app.rb
# Starting at line number: 47... 

  # Okay and now our Rack Handler to actually load the application
# on port 3001 of our computer.

Rack::Handler::WEBrick.run(App.new, {:Port => 3001})

# You should see the Rack output letting you know you have a server
# running, this time on port 3001.

# Open your browser again to http://localhost:3001

# And every time you hit refresh in your browser, you've been learning
# ruby for that much longer. Gives new meaning to this Sandi Metz quote.

# "You'll never be as stupid as you are right now."

# Hit refresh again, you've just gotten a few seconds smarter,
# a moment more familiar with Ruby.

# Okay, exit out of that server, shut it down with CTRL+C

# So we can put anything in that response? Hmm. I wonder what we can do...



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/002.a.dynamic.rack.app/app.rb
# Starting at line number: 45... 

  end

# Okay and now our Rack Handler to actually load the application
# on port 3001 of our computer.

Rack::Handler::WEBrick.run(App.new, {:Port => 3001})

# You should see the Rack output letting you know you have a server
# running, this time on port 3001.

# Open your browser again to http://localhost:3001

# And every time you hit refresh in your browser, you've been learning
# ruby for that much longer. Gives new meaning to this Sandi Metz quote.

# "You'll never be as stupid as you are right now."

# Hit refresh again, you've just gotten a few seconds smarter,
# a moment more familiar with Ruby.

# Okay, exit out of that server, shut it down with CTRL+C



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/002.a.dynamic.rack.app/app.rb
# Starting at line number: 42... 

  
    [200, {'Content-Type' => 'text/html'}, [response]]
  end
end

# Okay and now our Rack Handler to actually load the application
# on port 3001 of our computer.

Rack::Handler::WEBrick.run(App.new, {:Port => 3001})

# You should see the Rack output letting you know you have a server
# running, this time on port 3001.

# Open your browser again to http://localhost:3001

# And every time you hit refresh in your browser, you've been learning
# ruby for that much longer. Gives new meaning to this Sandi Metz quote.

# "You'll never be as stupid as you are right now."

# Hit refresh again, you've just gotten a few seconds smarter,



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/002.a.dynamic.rack.app/app.rb
# Starting at line number: 2... 

  # Again, ignore the following line.
Signal.trap('INT') {Rack::Handler::WEBrick.shutdown}

# We left off with this amazing but boring Ruby Rack powered
# application.

class App
  def call(env)
    [200, {'Content-Type' => 'text/html'}, ["Hi from Ruby 004, we &#9829; you!"]]
  end
end

# But wait, if we're going to be building Rack applications,
# we have to integrate that superpower into this current script.

require 'rack'




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/002.a.dynamic.rack.app/app.rb
# Starting at line number: 16... 

  end

# But wait, if we're going to be building Rack applications,
# we have to integrate that superpower into this current script.

require 'rack'

# Okay, so now we know that application above will respond with a static string.
# But what about a more complex one?

class App
  def call(env)
    seconds_in_17_days = 1468800 # I hope that's right.

    # Here comes a HERE doc. It's just a ruby string.
    response = <<-TXT
    Hi Ruby 004. It's #{Time.now}. 
    Hit refresh and realize you've been learning Ruby
    since #{(Time.now - seconds_in_17_days)}.
    How many days is that? 17? With weekends? And look what you're doing.
    Building a dynamic web application. I wonder what else you're capable of.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/002.a.dynamic.rack.app/app.rb
# Starting at line number: 13... 

    def call(env)
    [200, {'Content-Type' => 'text/html'}, ["Hi from Ruby 004, we &#9829; you!"]]
  end
end

# But wait, if we're going to be building Rack applications,
# we have to integrate that superpower into this current script.

require 'rack'

# Okay, so now we know that application above will respond with a static string.
# But what about a more complex one?

class App
  def call(env)
    seconds_in_17_days = 1468800 # I hope that's right.

    # Here comes a HERE doc. It's just a ruby string.
    response = <<-TXT
    Hi Ruby 004. It's #{Time.now}. 
    Hit refresh and realize you've been learning Ruby



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 9... 

  require 'rack'

# Okay, we're going to build a quick really simple
# web application.

# Rack is a ruby library for building web applications. Its a lot
# like our CLI class in that it provides an interface. The CLI interface
# is the Command Line, Rack's interface is the browser.

# First we have to do something weird to prevent some bugs for some
# of you. Really ignore this, it isn't a thing.
Signal.trap('INT') {Rack::Handler::WEBrick.shutdown}

# TODO that we're going to make a class called App.
# It basically represents our web application, as if
# it was as real a thing as the Dogs we've been creating.
class App
end

# Like lots of the things we've built so far, that class
# App, it isn't 'a' particular web app, but rather,



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 96... 

      [200, {'Content-Type' => 'text/html'}, ["Hi from Ruby 004, we &:heart you!"]]
  end
end

# So now every time a browser makes a request to our Rack Ruby Web
# Server Application, the Rack gem will create a new instance of our application
# and automatically trigger the call method to send back our HTTP 3 Part Response.

# But one more totally unreasonable thing. Web Applications are complex.
# There's a good chance we're not the first application to deal with this
# request. So each Rack Application passes the `call` method an argument,
# the environment of the request thus far. It's complicated and I'll explain it
# but for now, just know that the `call` method must accept an argument
# and we call it env. We don't even need to do anything with it, we just
# must accept it.

class App
  def call(env)
    [200, {'Content-Type' => 'text/html'}, ["Hi from Ruby 004, we &#9829; you!"]]
  end
end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 95... 

    def call
    [200, {'Content-Type' => 'text/html'}, ["Hi from Ruby 004, we &:heart you!"]]
  end
end

# So now every time a browser makes a request to our Rack Ruby Web
# Server Application, the Rack gem will create a new instance of our application
# and automatically trigger the call method to send back our HTTP 3 Part Response.

# But one more totally unreasonable thing. Web Applications are complex.
# There's a good chance we're not the first application to deal with this
# request. So each Rack Application passes the `call` method an argument,
# the environment of the request thus far. It's complicated and I'll explain it
# but for now, just know that the `call` method must accept an argument
# and we call it env. We don't even need to do anything with it, we just
# must accept it.

class App
  def call(env)
    [200, {'Content-Type' => 'text/html'}, ["Hi from Ruby 004, we &#9829; you!"]]
  end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 83... 

    # The call method expects this response delivered as a 3 part array.
  # [the_code, the_metadata_hash, the_body_array]
  # [200, {'Content-Type' => 'text/html'}, ["Hello World"]]

  # the_body_array is weird. Basically, HTTP supports multi-part
  # responses and thus a Rack response is sent as an array. The 
  # first part is consider the main body of the response, it's 
  # what we care about.

# Let's add this as the return value for our call method real quick.

class App
  def call
    [200, {'Content-Type' => 'text/html'}, ["Hi from Ruby 004, we &:heart you!"]]
  end
end

# So now every time a browser makes a request to our Rack Ruby Web
# Server Application, the Rack gem will create a new instance of our application
# and automatically trigger the call method to send back our HTTP 3 Part Response.




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 4... 

  # Let's get some superweb powers.

# Make sure to gem install rack first.
require 'rack'

# Okay, we're going to build a quick really simple
# web application.

# Rack is a ruby library for building web applications. Its a lot
# like our CLI class in that it provides an interface. The CLI interface
# is the Command Line, Rack's interface is the browser.

# First we have to do something weird to prevent some bugs for some
# of you. Really ignore this, it isn't a thing.
Signal.trap('INT') {Rack::Handler::WEBrick.shutdown}

# TODO that we're going to make a class called App.
# It basically represents our web application, as if
# it was as real a thing as the Dogs we've been creating.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 3... 

  # Let's get some superweb powers.

# Make sure to gem install rack first.
require 'rack'

# Okay, we're going to build a quick really simple
# web application.

# Rack is a ruby library for building web applications. Its a lot
# like our CLI class in that it provides an interface. The CLI interface
# is the Command Line, Rack's interface is the browser.

# First we have to do something weird to prevent some bugs for some
# of you. Really ignore this, it isn't a thing.
Signal.trap('INT') {Rack::Handler::WEBrick.shutdown}

# TODO that we're going to make a class called App.
# It basically represents our web application, as if



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 39... 

  # A Rack convention is to invoke the `call` method
# of an instance every time a new request from a browser
# comes in.

# If we define a `call` instance method on our App class
# it will instantly become a rack application.

class App
  def call
  end
end

# However, this call method has two issues, one reasonable one,
# and one incidentally complex one.

# The reasonable thing is that our call method does nothing.
# It needs to return a well-formed HTTP response to be 
# compatible with the internets.

# A HTTP Response is defined as three components.




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 34... 

  
# But our very first web app, well, it doesn't know
# how to do anything. We need to make it useful.
# It needs a call of action.

# A Rack convention is to invoke the `call` method
# of an instance every time a new request from a browser
# comes in.

# If we define a `call` instance method on our App class
# it will instantly become a rack application.

class App
  def call
  end
end

# However, this call method has two issues, one reasonable one,
# and one incidentally complex one.

# The reasonable thing is that our call method does nothing.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 15... 

  # like our CLI class in that it provides an interface. The CLI interface
# is the Command Line, Rack's interface is the browser.

# First we have to do something weird to prevent some bugs for some
# of you. Really ignore this, it isn't a thing.
Signal.trap('INT') {Rack::Handler::WEBrick.shutdown}

# TODO that we're going to make a class called App.
# It basically represents our web application, as if
# it was as real a thing as the Dogs we've been creating.
class App
end

# Like lots of the things we've built so far, that class
# App, it isn't 'a' particular web app, but rather,
# applications in general. If we want to have a web app,
# we need to make a web app.

our_very_first_web_app = App.new

# But our very first web app, well, it doesn't know



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 133... 

  # ruby 001.a.basic.rack.app/app.rb

# You should see some output that indicates that you've launched your
# first Ruby web server. Here's what I see.

# $ ruby 001.a.basic.rack.app/app.rb 
# [2013-10-18 06:34:13] INFO  WEBrick 1.3.1
# [2013-10-18 06:34:13] INFO  ruby 1.9.3 (2013-06-27) [x86_64-darwin12.3.0]
# [2013-10-18 06:34:13] INFO  WEBrick::HTTPServer#start: pid=18621 port=3000

# So right now, on your computer, using ruby, you just built a web application.
# It's a living thing, waiting on port 3000 of your computer, to respond to
# anything requesting an HTTP response (like your browser). It's running and
# waiting. Let's give it a request to respond to.

# Go get your moment of zen and open the following URL in your browser.

# http://localhost:3000

# localhost is just an easy way to refer to your own computer from your 
# own computer. the :3000 part is basically saying which port to use on your



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 128... 

  # instance, give it a port, and we've built a ruby web application.

Rack::Handler::WEBrick.run(our_very_first_web_app, {:Port => 3000})

# Try this from your terminal (from the root of this project).
# ruby 001.a.basic.rack.app/app.rb

# You should see some output that indicates that you've launched your
# first Ruby web server. Here's what I see.

# $ ruby 001.a.basic.rack.app/app.rb 
# [2013-10-18 06:34:13] INFO  WEBrick 1.3.1
# [2013-10-18 06:34:13] INFO  ruby 1.9.3 (2013-06-27) [x86_64-darwin12.3.0]
# [2013-10-18 06:34:13] INFO  WEBrick::HTTPServer#start: pid=18621 port=3000

# So right now, on your computer, using ruby, you just built a web application.
# It's a living thing, waiting on port 3000 of your computer, to respond to
# anything requesting an HTTP response (like your browser). It's running and
# waiting. Let's give it a request to respond to.

# Go get your moment of zen and open the following URL in your browser.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 125... 

  # called Webrick (we could use thin or unicorn or mongrel or whatever).

# We call a run method on that handler, pass it our application
# instance, give it a port, and we've built a ruby web application.

Rack::Handler::WEBrick.run(our_very_first_web_app, {:Port => 3000})

# Try this from your terminal (from the root of this project).
# ruby 001.a.basic.rack.app/app.rb

# You should see some output that indicates that you've launched your
# first Ruby web server. Here's what I see.

# $ ruby 001.a.basic.rack.app/app.rb 
# [2013-10-18 06:34:13] INFO  WEBrick 1.3.1
# [2013-10-18 06:34:13] INFO  ruby 1.9.3 (2013-06-27) [x86_64-darwin12.3.0]
# [2013-10-18 06:34:13] INFO  WEBrick::HTTPServer#start: pid=18621 port=3000

# So right now, on your computer, using ruby, you just built a web application.
# It's a living thing, waiting on port 3000 of your computer, to respond to
# anything requesting an HTTP response (like your browser). It's running and



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 11... 

  # Okay, we're going to build a quick really simple
# web application.

# Rack is a ruby library for building web applications. Its a lot
# like our CLI class in that it provides an interface. The CLI interface
# is the Command Line, Rack's interface is the browser.

# First we have to do something weird to prevent some bugs for some
# of you. Really ignore this, it isn't a thing.
Signal.trap('INT') {Rack::Handler::WEBrick.shutdown}

# TODO that we're going to make a class called App.
# It basically represents our web application, as if
# it was as real a thing as the Dogs we've been creating.
class App
end

# Like lots of the things we've built so far, that class
# App, it isn't 'a' particular web app, but rather,
# applications in general. If we want to have a web app,
# we need to make a web app.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 119... 

  # which port to run on, and what object to use as our application.

# Here is our application instance for Rack to use.
our_very_first_web_app = App.new

# Below is the weird Rack::Handler syntax to connect to a Ruby Webserver
# called Webrick (we could use thin or unicorn or mongrel or whatever).

# We call a run method on that handler, pass it our application
# instance, give it a port, and we've built a ruby web application.

Rack::Handler::WEBrick.run(our_very_first_web_app, {:Port => 3000})

# Try this from your terminal (from the root of this project).
# ruby 001.a.basic.rack.app/app.rb

# You should see some output that indicates that you've launched your
# first Ruby web server. Here's what I see.

# $ ruby 001.a.basic.rack.app/app.rb 
# [2013-10-18 06:34:13] INFO  WEBrick 1.3.1



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 116... 

  end

# And finally, we must instruct our Rack on which web server to use,
# which port to run on, and what object to use as our application.

# Here is our application instance for Rack to use.
our_very_first_web_app = App.new

# Below is the weird Rack::Handler syntax to connect to a Ruby Webserver
# called Webrick (we could use thin or unicorn or mongrel or whatever).

# We call a run method on that handler, pass it our application
# instance, give it a port, and we've built a ruby web application.

Rack::Handler::WEBrick.run(our_very_first_web_app, {:Port => 3000})

# Try this from your terminal (from the root of this project).
# ruby 001.a.basic.rack.app/app.rb

# You should see some output that indicates that you've launched your
# first Ruby web server. Here's what I see.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 113... 

    def call(env)
    [200, {'Content-Type' => 'text/html'}, ["Hi from Ruby 004, we &#9829; you!"]]
  end
end

# And finally, we must instruct our Rack on which web server to use,
# which port to run on, and what object to use as our application.

# Here is our application instance for Rack to use.
our_very_first_web_app = App.new

# Below is the weird Rack::Handler syntax to connect to a Ruby Webserver
# called Webrick (we could use thin or unicorn or mongrel or whatever).

# We call a run method on that handler, pass it our application
# instance, give it a port, and we've built a ruby web application.

Rack::Handler::WEBrick.run(our_very_first_web_app, {:Port => 3000})

# Try this from your terminal (from the root of this project).
# ruby 001.a.basic.rack.app/app.rb



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/rack-todo-ruby-004/001.a.basic.rack.app/app.rb
# Starting at line number: 101... 

  # Server Application, the Rack gem will create a new instance of our application
# and automatically trigger the call method to send back our HTTP 3 Part Response.

# But one more totally unreasonable thing. Web Applications are complex.
# There's a good chance we're not the first application to deal with this
# request. So each Rack Application passes the `call` method an argument,
# the environment of the request thus far. It's complicated and I'll explain it
# but for now, just know that the `call` method must accept an argument
# and we call it env. We don't even need to do anything with it, we just
# must accept it.

class App
  def call(env)
    [200, {'Content-Type' => 'text/html'}, ["Hi from Ruby 004, we &#9829; you!"]]
  end
end

# And finally, we must instruct our Rack on which web server to use,
# which port to run on, and what object to use as our application.

# Here is our application instance for Rack to use.



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/config-ru-todo-ruby-004/my-cool-app/spec/spec_helper.rb
# Starting at line number: 8... 

  
RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus
  config.include Rack::Test::Methods
  config.before do
    get '/'
  end

  config.order = 'default'
end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/config-ru-todo-ruby-004/my-cool-app/spec/integration/05_application_spec.rb
# Starting at line number: 5... 

  require_relative '../spec_helper'

describe 'Application' do
  def app
    Rack::Builder.parse_file('config.ru').first
  end

  it_behaves_like "an ok request"
  
  let(:expected_stuff) {[
    "<html>",
    "GET",
    "80",
    "<body>"
  ]}

  it 'returns html containing the correct elements' do
    # First test to see that correct elements exist
    expected_stuff.each do |element|
      expect(last_response.body).to match(/#{element}/)



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/labs/week4/config-ru-todo-ruby-004/hello-rack/hello_rack.rb
# Starting at line number: 5... 

  
class HelloRack
  def call(env)
    # puts env["REQUEST_PATH"]
    [200, {"Content-Type" => "text/html"}, ["Hello Rack!"]]

  end

end


###########################

# File: /Users/samschlinkert/Documents/code/flatiron/jot_notes/rsepc_and_sinatra_notes.rb
# Starting at line number: 63... 

  
  require 'rack/test'

  describe Foo do

    include Rack::Test::Methods

    def app
      Foo.new
    end

    it "should be testable" do
      get '/'
      last_response.should be_ok
    end

  end





###########################

# File: /Users/samschlinkert/Documents/code/flatiron/jot_notes/rsepc_and_sinatra_notes.rb
# Starting at line number: 5... 

  # Different ways to setup RSpec testing of Sinatra 

### From Sinatra recipes... 
  module RSpecMixin
    include Rack::Test::Methods
    def app() Sinatra::Application end
  end

  # For RSpec 2.x
  RSpec.configure { |c| c.include RSpecMixin }
  # If you use RSpec 1.x you should use this instead:
  Spec::Runner.configure { |c| c.include RSpecMixin }



### From http://www.sinatrarb.com/testing.html

  require 'hello_world'  # <-- your sinatra app
  require 'rspec'
  require 'rack/test'



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/jot_notes/rsepc_and_sinatra_notes.rb
# Starting at line number: 59... 

  


### From the StackOverflow Example

  require 'rack/test'

  describe Foo do

    include Rack::Test::Methods

    def app
      Foo.new
    end

    it "should be testable" do
      get '/'
      last_response.should be_ok
    end

  end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/jot_notes/rsepc_and_sinatra_notes.rb
# Starting at line number: 47... 

    def app 
    Sinatra:Application # If you’re using a classic style Sinatra application, then you need to return an instance of Sinatra::Application.
  end

  describe 'Reverse Service' do 
    include Rack::Test::Methods

    it "should load the homepage"
      get '/'
      last_response.should be_ok
    end
  end



### From the StackOverflow Example

  require 'rack/test'

  describe Foo do




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/jot_notes/rsepc_and_sinatra_notes.rb
# Starting at line number: 38... 

      end
  end

### From the video

  require 'rack/test' 

  set :environment, :test

  def app 
    Sinatra:Application # If you’re using a classic style Sinatra application, then you need to return an instance of Sinatra::Application.
  end

  describe 'Reverse Service' do 
    include Rack::Test::Methods

    it "should load the homepage"
      get '/'
      last_response.should be_ok
    end
  end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/jot_notes/rsepc_and_sinatra_notes.rb
# Starting at line number: 23... 

    require 'hello_world'  # <-- your sinatra app
  require 'rspec'
  require 'rack/test'

  describe 'The HelloWorld App' do
    include Rack::Test::Methods

    def app
      Sinatra::Application
    end

    it "says hello" do
      get '/'
      expect(last_response).to be_ok
      expect(last_response.body).to eq('Hello World')
    end
  end

### From the video

  require 'rack/test' 



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/jot_notes/rsepc_and_sinatra_notes.rb
# Starting at line number: 20... 

  
### From http://www.sinatrarb.com/testing.html

  require 'hello_world'  # <-- your sinatra app
  require 'rspec'
  require 'rack/test'

  describe 'The HelloWorld App' do
    include Rack::Test::Methods

    def app
      Sinatra::Application
    end

    it "says hello" do
      get '/'
      expect(last_response).to be_ok
      expect(last_response.body).to eq('Hello World')
    end
  end




###########################

# File: /Users/samschlinkert/Documents/code/flatiron/assessments/sinatra-orm-quiz-ruby-004/spec/spec_helper.rb
# Starting at line number: 4... 

  require_relative '../config/environment'
Bundler.require(:test)

require 'rack/test'
require 'capybara/rspec'
require 'capybara/dsl'

RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus
  config.include Rack::Test::Methods
  config.include Capybara::DSL

  config.before do
    ActiveRecord::Base.connection.tables.each do |t|
      ActiveRecord::Base.connection.execute("DROP TABLE #{t}")
    end
  end



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/assessments/sinatra-orm-quiz-ruby-004/spec/spec_helper.rb
# Starting at line number: 12... 

  
RSpec.configure do |config|
  config.treat_symbols_as_metadata_keys_with_true_values = true
  config.run_all_when_everything_filtered = true
  config.filter_run :focus
  config.include Rack::Test::Methods
  config.include Capybara::DSL

  config.before do
    ActiveRecord::Base.connection.tables.each do |t|
      ActiveRecord::Base.connection.execute("DROP TABLE #{t}")
    end
  end

  config.after do
    ActiveRecord::Base.connection.tables.each do |t|
      ActiveRecord::Base.connection.execute("DROP TABLE #{t}")
    end
  end

  config.order = 'default'



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/assessments/rails_assessment/config/environments/production.rb
# Starting at line number: 18... 

    # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.
  config.assets.digest = true



###########################

# File: /Users/samschlinkert/Documents/code/flatiron/assessments/rails_assessment/config/environments/production.rb
# Starting at line number: 17... 

  
  # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Enable Rack::Cache to put a simple HTTP cache in front of your application
  # Add `rack-cache` to your Gemfile before enabling this.
  # For large-scale production use, consider using a caching reverse proxy like nginx, varnish or squid.
  # config.action_dispatch.rack_cache = true

  # Disable Rails's static asset server (Apache or nginx will already do this).
  config.serve_static_assets = false

  # Compress JavaScripts and CSS.
  config.assets.js_compressor = :uglifier
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Generate digests for assets URLs.

